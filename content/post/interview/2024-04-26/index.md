---
author: Alex Yan
title: 整理面试题 2
description: 整理面试题 2
date: 2024-04-25T21:28:02+08:00
#draft: 
tags: [
    "面试"
]
categories: [
    "log",
]
#image: "create-blog-01.jpg"
#aliases: ["create-blog-1"]
---

# cdn是什么

* CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输得更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决
Internet网络拥挤的状况，提高用户访问网站的响应速度。

# 介绍一下了解的应用服务发布策略

1. 蓝绿发布
* 项目逻辑上分为AB组，在项目系统时，首先把A组从负载均衡中摘除，进行新版本的部署。B组仍然继续提供服务。
![alt text](img/blog/blog-image-13.png)
* 当A组升级完毕，负载均衡重新接入A组，再把B组从负载列表中摘除，进行新版本的部署。A组重新提供服务。
![alt text](img/blog/blog-image-14.png)
* 最后，B组也升级完成，负载均衡重新接入B组，此时，AB组版本都已经升级完成，并且都对外提供服务。

> 优点
> * 如果出问题，影响范围较小；
> * 发布策略简单；
> * 用户无感知，平滑过渡；
> * 升级/回滚速度快。

> 缺点
> * 需要准备正常业务使用资源的两倍以上服务器，防止升级期间单组无法承载业务突发；
> * 短时间内浪费一定资源成本；
> * 基础设施无改动，增大升级稳定性。

> 蓝绿发布在早期物理服务器时代，还是比较昂贵的，由于云计算普及，成本也大大降低。

2. 灰度发布
* 灰度发布只升级部分服务，即让一部分用户继续用老版本，一部分用户开始用新版本，如果用户对新版本没什么意见，那么逐步扩大范围，把所有用户都迁移到新版本上面来。
![alt text](img/blog/blog-image-15.png)

> 优点
> * 保证整体系统稳定性，在初始灰度的时候就可以发现、调整问题，影响范围可控；
> * 新功能逐步评估性能，稳定性和健康状况，如果出问题影响范围很小，相对用户体验也少；
> * 用户无感知，平滑过渡。

> 缺点
> * 自动化要求高。

> 部署过程
> * 从LB摘掉灰度服务器，升级成功后再加入LB；
> * 少量用户流量到新版本；
> * 如果灰度服务器测试成功，升级剩余服务器。

> 灰度发布是通过切换线上并存版本之间的路由权重，逐步从一个版本切换为另一个版本的过程。

3. 滚动发布
* 滚动发布是指每次只升级一个或多个服务，升级完成后加入生产环境，不断执行这个过程，直到集群中的全部旧版本升级新版本。
![alt text](img/blog/blog-image-16.png)
* 红色：正在更新的实例
* 蓝色：更新完成并加入集群的实例
* 绿色：正在运行的实例

> 优点
> * 用户无感知，平滑过渡；
> * 节约资源。

> 缺点
> * 部署时间慢，取决于每阶段更新时间；
> * 发布策略较复杂；
> * 无法确定OK的环境，不易回滚。

> 部署过程
> * 先升级1个副本，主要做部署验证；
> * 每次升级副本，自动从LB上摘掉，升级成功后自动加入集群；
> * 事先需要有自动更新策略，分为若干次，每次数量/百分比可配置；
> * 回滚是发布的逆过程，先从LB摘掉新版本，再升级老版本，这个过程一般时间比较长；
> * 自动化要求高。


> 综上所述，三种方式均可以做到平滑式升级，在升级过程中服务仍然保持服务的连续性，升级对外界是无感知的。那生产上选择哪种部署方法最合适呢？这取决于哪种方法最适合你的业务和技术需求。如果你们运维自动化能力储备不够，肯定是越简单越好，建议蓝绿发布，如果业务对用户依赖很强，建议灰度发布。如果是K8S平台，滚动更新是现成的方案，建议先直接使用。
> * 蓝绿发布：两套环境交替升级，旧版本保留一定时间便于回滚。
> * 灰度发布：根据比例将老版本升级，例如80%用户访问是老版本，20%用户访问是新版本。
> * 滚动发布：按批次停止老版本实例，启动新版本实例。

# 七层和四层负载均衡的用途和区别

* 四层负载均衡工作在OSI模型的传输层，由于在传输层，只有TCP/UDP协议，这两种协议中除了包含源IP、目标IP以外，还包含源端口号及目的端口号。四层负载均衡服务器在接受到客户端请求后，以后通过修改数据包的地址信息（IP+端口号）将流量转发到应用服务器
* 七层负载均衡工作在OSI模型的应用层，应用层协议较多，常用http、radius、dns等。七层负载就可以基于这些协议来负载。这些应用层协议中会包含很多有意义的内容。比如同一个Web服务器的负载均衡，除了根据IP加端口进行负载外，还可根据七层的URL、浏览器类别、语言来决定是否要进行负载均衡。对于一般的应用来说，有了Nginx就够了。Nginx可以用于七层负载均衡。但是对于一些大的网站，一般会采用DNS+四层负载+七层负载的方式进行多层次负载均衡。
* 四层就是基于 IP + 端口的负载均衡；
* 七层即应用层，就是基于 URL 等应用层信息的负载均衡；

# 两台机器实现高可用的ip

* 使用keepalived实现vip的自动漂移

# k8s中deployment组件和statefulset组件的区别

1. 应用场景：
* Deployment主要用于部署无状态服务，即服务实例之间可以相互替换且不需要保留特定的网络标识或存储数据。
* StatefulSet适用于有状态的应用场景，如需要持久化存储的应用程序（数据库、消息队列等），每个Pod都有明确且不变的唯一标识，以便在Pod重启或迁移时保持状态稳定性。
2. Pod身份与标识：
* Deployment创建的Pod身份不固定，虽然可以自定义名称，但通常由系统生成，并在重建或扩展时可能会发生变化。
* StatefulSet为每个Pod分配了唯一的、不变的标识符，确保Pod在重新部署时保持相同的标识符。
3. 扩展与启动顺序：
* Deployment支持Pod的动态扩缩容，并可以处理Pod的增删改以达到预期配置。
* StatefulSet则保证了Pod的有序部署和扩展，满足那些依赖于严格顺序启动或停止的应用场景需求。

> 综上所述，Deployment和StatefulSet在K8s中各自扮演着不同的角色，适用于不同的应用场景，并具备不同的特性和功能。高级工程师在选择使用哪种组件时，需要根据具体的应用需求和场景来做出决策。

# k8s中headless service
> Service解决了Pod的内外部访问问题，允许客户端连接到Service关联的某个Pod。但还有下面这些问题没解决。
1. 同时访问所有Pod
2. 一个Service内部的Pod互相访问

> 为了解决以上问题，Kubernetes提供了另一种较为特殊的Service类型，称为Headless Service。对于其他Service来说，客户端在访问服务时，DNS查询时只会返回Service的ClusterIP地址，具体访问到哪个Pod是由集群转发规则（IPVS或iptables）决定的。而Headless Service并不会分配单独的ClusterIP，在进行DNS查询时会返回所有Pod的DNS记录，这样就可查询到每个Pod的IP地址。StatefulSet中StatefulSet正是使用Headless Service解决Pod间互相访问的问题。

# k8s nginx ingress动态转入机制的原理
> igress controller通过和kubernetes api交互，动态的去感知集群中ingress规则变化，
然后读取它，按照自定义的规则，规则就是写明了哪个域名对应哪个service，生成一段nginx配置，
再写到nginx-ingress-controller的pod里，这个Ingress
controller的pod里运行着一个Nginx服务，控制器会把生成的nginx配置写入/etc/nginx.conf文件中，
然后reload一下使配置生效。以此达到域名分配置和动态更新的问题。

# k8s探针liveness probe、Readiness Probe的区别
1. liveness probe 回答了用来检测容器内的应用程序是否正常工作
2. Readiness Probe，能让你确认应用可访问，只有探针通过后，k8s才将流量转发给pod。

# 容器内服务会出现僵尸进程，如何构建镜像保证服务稳定
> 回答了容器内使用脚本检测僵尸进程完成服务重启，属于胖容器
1. 瘦容器不清楚
用docker启动容器的时候加--init参数，容器就强制使用tini作为init进程了。tini的主进程里，就是不断在调用带WNOHANG 参数的 waitpid()，通过这个方式清理容器中所有的僵尸进程。
https://www.coder.work/article/41087
https://blog.csdn.net/Ffffatass/article/details/119329671
https://blog.csdn.net/justsomebody126/article/details/106686391

2. 胖容器
https://blog.csdn.net/whatday/article/details/104136271

# k8s operator模式的调度逻辑
https://cloud.tencent.com/developer/article/1793656

# docker镜像多阶段构建使用的场景
> 多个 FROM 指令并不是为了生成多根的层关系，最后生成的镜像，仍以最后一条 FROM 为准，之前的 FROM 会被抛弃，那么之前的FROM 又有什么意义呢？
每一条 FROM 指令都是一个构建阶段，多条 FROM 就是多阶段构建，虽然最后生成的镜像只能是最后一个阶段的结果，但是，能够将前置阶段中的文件拷贝到后边的阶段中，这就是多阶段构建的最大意义。
最大的使用场景是将编译环境和运行环境分离
* 参考

https://blog.csdn.net/weixin_42852772/article/details/82013418
https://blog.csdn.net/qq_43762191/article/details/125589205?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-8-125589205-blog-82013418.pc_relevant_aa2&spm=1001.2101.3001.4242.5&utm_relevant_index=11

# mysql恢复到任意时间节点的方法
全量备份加基于GTID的binlog日志的增量备份

# 之前遇到的问题，通过什么方式解决的
linux系统存储空间df 显示的已使用磁盘占用率比du 统计出来的结果要大很多， lsof |grep deleted  查看了有进程在使用被删除文件，df -i发现inode资源消耗过多，停止相关进程释放空间，或者echo > xxx 使用清空代替删除操作，直接释放inode资源

https://blog.csdn.net/weixin_34111790/article/details/93108530