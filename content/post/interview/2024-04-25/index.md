---
author: Alex Yan
title: 整理面试题 1
description: 整理面试题 1
date: 2024-04-25T20:28:02+08:00
#draft: 
tags: [
    "面试"
]
categories: [
    "log",
]
#image: "create-blog-01.jpg"
#aliases: ["create-blog-1"]
---

# 2024-04-25

## Nginx和LVS的区别
1. 工作机制和原理：
* Nginx：Nginx是一个高性能的HTTP和反向代理服务器，也是一个IMAP/POP3/SMTP代理服务器。它主要工作在应用层（第七层），使用事件驱动架构来处理连接。Nginx可以处理静态和动态内容，并提供负载均衡、内容缓存和SSL加密等功能。
* LVS：LVS（Linux Virtual Server）是一个基于Linux内核的高性能负载均衡解决方案。它工作在网络层（第四层），利用内核级的IP转发功能来实现负载均衡。LVS通过NAT（网络地址转换）或隧道模式（Tunneling）将客户端的请求分发到后端服务器。
2. 性能：
* Nginx：Nginx在处理HTTP请求时表现优异，但由于它工作在应用层，对TCP/IP协议的处理能力相对较弱。因此，在高并发场景下，Nginx的性能可能不如LVS。
* LVS：由于LVS工作在网络层，直接处理IP包，因此在处理大量并发连接时性能非常高。此外，LVS支持多种负载均衡算法，如轮询、加权轮询、最小连接数等，可以根据实际需求选择合适的算法。
3. 扩展性和灵活性：
* Nginx：Nginx的模块化和可扩展性使得它可以根据具体需求添加或删除功能模块。此外，Nginx支持动态配置，可以在运行时重新加载配置文件，使得配置更改更加灵活。
* LVS：LVS的扩展性较好，可以通过添加更多的后端服务器来提高处理能力。然而，LVS的配置相对固定，一旦配置完成，修改起来较为麻烦。

4. 应用场景：
* Nginx：Nginx通常用于处理HTTP请求，提供反向代理、负载均衡和缓存等功能。此外，Nginx还支持SSL加密、限流、访问控制等功能，适用于Web应用、API网关等场景。
* LVS：LVS主要适用于大型高并发场景，如网站、在线游戏、视频分享等。它可以处理大量的TCP/IP连接，实现高效的负载均衡。

综上所述，Nginx和LVS各有优势，具体选择哪种方案取决于实际需求和应用场景。对于高性能、高并发的场景，LVS可能更适合；而对于需要更多功能扩展和灵活配置的场景，Nginx可能更适合。

> 四层：
链路层：也称为网络接口层，负责处理网络连接的物理细节，包括电缆、网卡、路由器和其他网络设备的接口。
网络层：负责处理网络地址和数据的路由，确保数据包能够被发送到正确的目标地址，并选择最佳的路径进行传输。
传输层：负责数据的分段和重组，以确保数据能够在发送和接收的两个系统之间正确无误地传输，还负责错误检查和流量控制，以确保数据的可靠传输。
应用层：是协议的最高层，负责处理特定的应用程序细节。

> 七层：
OSI模型定义了网络互连的七层框架，从低到高分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。

## 怎么查看服务器网络连接情况
1. netstat -an 。该命令将显示所有的网络连接，包括TCP和UDP的连接。"-a"参数表示显示所有连接，"-n"参数表示以数字形式显示IP地址和端口号。
2. lsof -i 。该命令将显示当前所有打开的网络连接信息，包括进程ID、进程名、协议、IP地址和端口号等。
3. ss -tunap 。该命令将显示所有TCP和UDP连接的详细信息，包括进程ID、进程名、本地地址、远程地址、状态等。
4. 此外，还可以使用专业的网络工具，如PingPlotter、Wireshark等来检测服务器的连接情况。

## 磁盘索引inode怎么查看

1. 磁盘容量inode信息使用下面命令查看
```
df -i
```
2. 如果需要查看每个inode节点的大小，可以使用以下命令，其中"/dev/sdaX"表示要查看的磁盘分区。
```
sudo dumpe2fs -h /dev/sdaX | grep "Inode size"
```
## inode满了有什么影响，怎么解决
* inode满会导致文件无法创建、新应用无法安装以及无法删除文件等。
inode是Linux文件系统中的基本数据结构，它存储着文件和目录的详细信息，包括文件大小、权限、日期等。每个inode都可以存储一定的信息，而inode的数量是有限的，当所有的inode被用光时，就会出现inode满的问题
* inode满了的解决方法如下：
1. 清理不必要的文件 。首先检查文件系统中不再需要的文件，并将其删除。
2. 删除不必要的软链接 。软链接是指向其他文件或目录的指针，可以通过删除不再需要的软链接来释放inode。
3. 清理临时文件 。一些应用程序或系统进程会在运行时创建临时文件，可以使用tmpreaper等工具来清理这些临时文件。
4. 扩展文件系统 。如果上述方法无法释放足够的inode，可以考虑扩展文件系统。
5. 调整文件系统参数 。可以通过修改文件系统参数来增加inode的数量。

## 增加inode数量
* 先卸载文件系统，然后使用mkfs.ext3命令创建文件系统，并通过-N参数指定inode节点数，最后重新挂载文件系统并查看修改后的inode参数1。
> 请注意，调整inode数量会格式化磁盘，执行前请确定磁盘上没有重要数据或是先备份数据

## TCP建立连接步骤及它的重传机制

> TCP建立连接步骤为三次握手：
1. 客户端发送连接请求包SYN和一个序列号SEQ到服务器，自身进入发送请求状态。
2. 服务器端接收到客户端发送的SYN请求包后必须进行确认，并回应一个SYN包和确认包ACK以及序列号SEQ+1，自身进入接收请求状态。
3. 客户端收到服务器的回应之后会发送一个ACK确认包，自身进入已连接状态。
4. 服务器端收到客户端发送的ACK确认包后自身进入已连接状态，完成三次握手。

> 重传机制
* TCP的重传机制依赖于序列号SEQ以及确认应答ACK，当TCP发送一个报文段后，会等待对方回复一个确认应答ACK，若在一定时间内未收到确认应答ACK，则会重新发送该报文段，直到收到确认应答ACK或达到最大重传次数为止。

## Linux 平均负载 Load Average 详解

1. 什么是Load Average？
> * 系统负载（System Load）是系统CPU繁忙程度的度量，即有多少进程在等待被CPU调度（进程等待队列的长度）。
> * 平均负载（Load Average）是一段时间内系统的平均负载，这个一段时间一般取1分钟、5分钟、15分钟。

2. 如何查看Load Average？
```shell
# 方法一：uptime
$ uptime
16:48:24 up  4:11,  1 user,  load average: 25.25, 23.40, 23.46

# 方法二：top
$ top - 16:48:42 up  4:12,  1 user,  load average: 25.25, 23.14, 23.37

# 方法三：cat /proc/loadavg
$ cat /proc/loadavg 
25.72 23.19 23.35 42/3411 43603
```

3. Load Average的3个数值各是什么意思？
* 第一位：表示最近1分钟平均负载
* 第二位：表示最近5分钟平均负载
* 第三位：表示最近15分钟平均负载

4. Load Average值的含义：
* 单核处理器（例如：1个1核cpu）
> 假设我们的系统是单CPU单内核的，把它比喻成是一条单向马路，把CPU任务比作汽车。
当车不多的时候，load <1；
当车占满整个马路的时候 load=1；
当马路都站满了，而且马路外还堆满了汽车的时候，load>1；
![alt text](img/blog/blog-image-11.png)

* 多核处理器 （例如：2个cpu或一个2核的cpu）
> 我们经常会发现服务器Load > 1但是运行仍然不错，那是因为服务器是多核处理器（Multi-core）。
假设我们服务器一个CPU是2核，那么将意味我们拥有2条马路，我们的Load = 2时，所有马路都跑满车辆。
![alt text](img/blog/blog-image-12.png)

> 提示：
芯片厂商往往在一个CPU内部，包含多个CPU核心，这被称为多核CPU。
在系统负荷方面，多核CPU与多个CPU效果类似，所以考虑系统负荷的时候，必须考虑这台电脑有几个CPU、每个CPU有几个核心。然后，把系统负荷除以总的核心数，只要每个核心的负荷不超过1.0，就表明电脑正常运行。

5. 怎么知道Linux服务器有多少个CPU核心呢？
```shell
# 查看cpu信息命令：
$ cat /proc/cpuinfo  
# 查看cpu总核心数命令：
$ grep 'model name' /proc/cpuinfo | wc -l  
$ grep -c 'model name' /proc/cpuinfo 
```
6. 什么样的Load Average值得警惕（单核）？
* Load < 0.7时：系统很闲，马路上没什么车，要考虑多部署一些服务
* 0.7 < Load < 1时：系统状态不错，马路可以轻松应对
* Load == 1时：系统马上要处理不多来了，赶紧找一下原因
* Load > 1时：马路已经非常繁忙了，进入马路的每辆汽车都要无法很快的运行

7. 三种Load Average值，应该看哪个（单核）？
* 通常我们先看15分钟load，如果load很高，再看1分钟和5分钟负载，查看是否有下降趋势。
* 1分钟负载值 > 1，那么我们不用担心，但是如果15分钟负载都超过1，我们要赶紧看看发生了什么事情。所以我们要根据实际情况查看这三个值。
* 现在相信大家都知道，“load average"一共返回三个平均值：1分钟系统负荷、5分钟系统负荷，15分钟系统负荷；
* 如果只有1分钟的系统负荷大于1.0，其他两个时间段都小于1.0，这表明只是暂时现象，问题不大。
* 如果15分钟内，平均系统负荷大于1.0（调整CPU核心数之后），表明问题持续存在，不是暂时现象。所以，你应该主要观察"15分钟系统负荷”，将它作为电脑正常运行的指标。

> 结合具体情况具体分析（单核）：
* 1分钟Load>1，5分钟Load<1，15分钟Load<1：短期内繁忙，中长期空闲，初步判断是一个“抖动”，或者是“拥塞前兆”
* 1分钟Load>1，5分钟Load>1，15分钟Load<1：短期内繁忙，中期内紧张，很可能是一个“拥塞的开始”
* 1分钟Load>1，5分钟Load>1，15分钟Load>1：短、中、长期都繁忙，系统“正在拥塞”
* 1分钟Load<1，5分钟Load>1，15分钟Load>1：短期内空闲，中、长期繁忙，不用紧张，系统“拥塞正在好转”

## time_wait连接状态多，什么原因，怎么解决
原因
1. HTTP没有使用长连接：服务器主动关闭连接时，每个连接都要进行四次挥手，导致出现大量TIME_WAIT状态。
2. HTTP长连接超时：长连接有超时时间，超过时间服务器会主动关闭连接，出现TIME_WAIT状态。
3. HTTP长连接请求数量达到上限：服务器会主动关闭一些连接，导致出现TIME_WAIT状态

解决
1. 客户端，调整短链接为长链接，HTTP 请求的头部，connection 设置为 keep-alive，保持存活一段时间
2. 服务器端允许 time_wait 状态的 socket 被重用缩减 time_wait 时间，设置为 1 MSL（即，2 mins）

## 客户端向服务端发送syn包尝试建立连接，服务端发现该端口连接已经存在,回复客户端什么包
* 处于 establish 状态的服务端如果收到了客户端的 SYN 报文（注意此时的 SYN 报文其实是乱序的，因为 SYN 报文的初始化序列号其实是一个随机数），会回复一个携带了正确序列号和确认号的 ACK 报文，这个 ACK 被称之为 Challenge ACK。接着，客户端收到这个 Challenge ACK，发现序列号并不是自己期望收到的，于是就会回 RST 报文，服务端收到后，就会释放掉该连接。

## docker容器挂了怎么查看问题

1. 使用docker inspect命令 。该命令可以获取有关容器的详细信息，包括容器的状态。可以执行docker inspect <容器ID>命令来检查容器的状态，如果容器的State字段显示为"exited"或"dead"，则表示容器已停止或出现故障。
2. 使用docker logs命令 。该命令可以查看容器的日志信息，执行docker logs <容器ID>命令来查看容器的日志，通过查看日志可以判断容器是否出现故障或错误信息。

## docker运行的服务器磁盘占用满了。怎么解决
> Docker在不重建容器的情况下，日志文件默认会一直追加，时间一长会逐渐占满服务器的硬盘的空间，内存消耗也会一直增加。

1. docker system df ----查看Docker占用分布 
2. docker stats ---可以查看docker容器的内存占用

3. 定时清理日志
```shell
logs=`find /var/lib/docker/containers/ -name *-json.log`
cat /dev/null > $log
```
4. docker run时添加--log-opt max-size=500m --log-opt max-file=3参数,如创建并运行
docker run -name xxx -p 80:80 --log-opt max-size=500m  --log-opt max-file=3 xxx:v1 

5. 通过配置容器docker-compose的max-size选项来实现
```yaml
logging:
    driver: "json-file"
    options:
        max-size: "500m"      # 日志文件大小
        max-file: "6"		# 日志的数量
```

## Redis主从数据不一致怎么解决

1. 理解主从同步机制：

* Redis的主从复制是基于内存的快照方式进行的。主服务器会将自己的数据快照发送给从服务器，从服务器接收后加载这个快照，然后持续接收主服务器的写操作命令，保持与主服务器的同步。
* 在这个过程中，如果网络不稳定、主服务器压力大或磁盘IO等问题，都可能导致主从同步出现问题。

2. 分析数据不一致的原因：

* 网络问题：网络延迟或网络中断可能导致主从同步中断，进而引发数据不一致。
* 主服务器负载过高：主服务器在处理大量请求时，可能会延迟向从服务器发送数据，导致从服务器数据滞后。
* 从服务器延迟处理：从服务器在接收并处理主服务器发送的数据时，如果处理速度较慢，也会导致数据不一致。
* 人为误操作：如错误的手动同步、删除或修改数据等操作。

3. 深度解决策略：

* 优化网络：确保主从服务器之间的网络连接稳定，并尽量减少网络延迟。
* 读写分离：根据业务场景，对读和写操作进行分离，将读请求发送到从服务器，减少主服务器的压力。
* 监控与告警：使用Redis的监控工具，如redis-cli info replication，监控主从同步的状态，并在出现延迟或错误时及时告警。
* 数据一致性校验：定期或实时对主从服务器的数据进行一致性校验，如使用工具如redis-check-replication。
* 数据恢复策略：制定完备的数据备份和恢复策略，在出现数据不一致时，可以快速恢复数据。
* 重新复制数据 。如果主从数据不一致且无法修复，可以尝试重新进行主从复制。首先解除从服务器的复制关系，然后再重新将从服务器设置为主服务器的从属节点，进行全量复制。

4. 高级配置与优化：

* **调整repl-timeout**：根据网络环境和主服务器负载，适当调整主从同步的超时时间。
* **开启min-replicas-to-write和min-replicas-max-lag**：确保至少有一定数量的从服务器与主服务器保持同步，并且这些从服务器的延迟在可接受的范围内。
* **使用redis-sentinel或redis-cluster**：对于更高级的场景，可以使用Redis Sentinel进行故障转移，或使用Redis Cluster进行数据分片和故障恢复。

> 总之，解决Redis主从数据不一致的问题需要从多个方面进行分析和优化，包括理解主从同步机制、分析数据不一致的原因、实施深度解决策略以及进行高级配置与优化。同时，持续监控和定期的数据一致性校验也是确保数据一致性的关键。